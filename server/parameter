#protocol.c#:    ttp_transfer_t  *xfer      = &session->transfer;
#protocol.c#:    ttp_parameter_t *param     = session->parameter;
#protocol.c#:    status = write(session->client_fd, random, 64);
#protocol.c#:    status = read(session->client_fd, client_digest, 16);
#protocol.c#:	    write(session->client_fd, "\001", 1);
#protocol.c#:    status = write(session->client_fd, "\000", 1);
#protocol.c#:    status = write(session->client_fd, &server_revision, 4);
#protocol.c#:    status = read(session->client_fd, &client_revision, 4);
#protocol.c#:    u_char              ipv6_yn = session->parameter->ipv6_yn;
#protocol.c#:    session->transfer.udp_length = ipv6_yn ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);
#protocol.c#:    address = (struct sockaddr *) malloc(session->transfer.udp_length);
#protocol.c#:    getpeername(session->client_fd, address, &(session->transfer.udp_length));
#protocol.c#:    status = read(session->client_fd, &port, 2);
#protocol.c#:    if (session->parameter->verbose_yn)
#protocol.c#:    session->transfer.udp_fd = create_udp_socket(session->parameter);
#protocol.c#:    if (session->transfer.udp_fd < 0)
#protocol.c#:    session->transfer.udp_address = address;
#protocol.c#:    ttp_transfer_t  *xfer  = &session->transfer;
#protocol.c#:    ttp_parameter_t *param =  session->parameter;
#protocol.c#:    status = read_line(session->client_fd, filename, MAX_FILENAME_LENGTH);
#protocol.c#:    status = write(session->client_fd, "\000", 1);
#protocol.c#:    if (read(session->client_fd, &param->block_size,  4) < 0) return warn("Could not read block size");            param->block_size  = ntohl(param->block_size);
#protocol.c#:    if (read(session->client_fd, &param->target_rate, 4) < 0) return warn("Could not read target bitrate");        param->target_rate = ntohl(param->target_rate);
#protocol.c#:    if (read(session->client_fd, &param->error_rate,  4) < 0) return warn("Could not read error rate");            param->error_rate  = ntohl(param->error_rate);
#protocol.c#:    if (read(session->client_fd, &param->slower_num,  2) < 0) return warn("Could not read slowdown numerator");    param->slower_num  = ntohs(param->slower_num);
#protocol.c#:    if (read(session->client_fd, &param->slower_den,  2) < 0) return warn("Could not read slowdown denominator");  param->slower_den  = ntohs(param->slower_den);
#protocol.c#:    if (read(session->client_fd, &param->faster_num,  2) < 0) return warn("Could not read speedup numerator");     param->faster_num  = ntohs(param->faster_num);
#protocol.c#:    if (read(session->client_fd, &param->faster_den,  2) < 0) return warn("Could not read speedup denominator");   param->faster_den  = ntohs(param->faster_den);
#protocol.c#:    file_size   = htonll(param->file_size);    if (write(session->client_fd, &file_size,   8) < 0) return warn("Could not submit file size");
#protocol.c#:    block_size  = htonl (param->block_size);   if (write(session->client_fd, &block_size,  4) < 0) return warn("Could not submit block size");
#protocol.c#:    block_count = htonl (param->block_count);  if (write(session->client_fd, &block_count, 4) < 0) return warn("Could not submit block count");
#protocol.c#:    epoch       = htonl (param->epoch);        if (write(session->client_fd, &epoch,       4) < 0) return warn("Could not submit run epoch");
io.c:	fseeko64(session->transfer.file, ((u_int64_t) session->parameter->block_size) * (block_index - 1), SEEK_SET);
io.c:    status = fread(datagram + 6, 1, session->parameter->block_size, session->transfer.file);
main.c:    ttp_transfer_t   *xfer  = &session->transfer;
main.c:    ttp_parameter_t  *param =  session->parameter;
main.c:    status = ttp_authenticate(session, session->parameter->secret);
main.c:	status = fcntl(session->client_fd, F_SETFL, 0);
main.c:	status = fcntl(session->client_fd, F_SETFL, O_NONBLOCK);
main.c:	    result = read(session->client_fd, &retransmission, sizeof(retransmission));
main.c:		    result = read(session->client_fd, &retransmission, sizeof(retransmission) - sofar);
protocol.c:    ttp_transfer_t  *xfer      = &session->transfer;
protocol.c:    ttp_parameter_t *param     = session->parameter;
protocol.c:    status = write(session->client_fd, random, 64);
protocol.c:    status = read(session->client_fd, client_digest, 16);
protocol.c:	    write(session->client_fd, "\001", 1);
protocol.c:    status = write(session->client_fd, "\000", 1);
protocol.c:    status = write(session->client_fd, &server_revision, 4);
protocol.c:    status = read(session->client_fd, &client_revision, 4);
protocol.c:    u_char              ipv6_yn = session->parameter->ipv6_yn;
protocol.c:    session->transfer.udp_length = ipv6_yn ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);
protocol.c:    address = (struct sockaddr *) malloc(session->transfer.udp_length);
protocol.c:    getpeername(session->client_fd, address, &(session->transfer.udp_length));
protocol.c:    status = read(session->client_fd, &port, 2);
protocol.c:    if (session->parameter->verbose_yn)
protocol.c:    session->transfer.udp_fd = create_udp_socket(session->parameter);
protocol.c:    if (session->transfer.udp_fd < 0)
protocol.c:    session->transfer.udp_address = address;
protocol.c:    ttp_transfer_t  *xfer  = &session->transfer;
protocol.c:    ttp_parameter_t *param =  session->parameter;
protocol.c:    status = read_line(session->client_fd, filename, MAX_FILENAME_LENGTH);
protocol.c:    status = write(session->client_fd, "\000", 1);
protocol.c:    if (read(session->client_fd, &param->block_size,  4) < 0) return warn("Could not read block size");            param->block_size  = ntohl(param->block_size);
protocol.c:    if (read(session->client_fd, &param->target_rate, 4) < 0) return warn("Could not read target bitrate");        param->target_rate = ntohl(param->target_rate);
protocol.c:    if (read(session->client_fd, &param->error_rate,  4) < 0) return warn("Could not read error rate");            param->error_rate  = ntohl(param->error_rate);
protocol.c:    if (read(session->client_fd, &param->slower_num,  2) < 0) return warn("Could not read slowdown numerator");    param->slower_num  = ntohs(param->slower_num);
protocol.c:    if (read(session->client_fd, &param->slower_den,  2) < 0) return warn("Could not read slowdown denominator");  param->slower_den  = ntohs(param->slower_den);
protocol.c:    if (read(session->client_fd, &param->faster_num,  2) < 0) return warn("Could not read speedup numerator");     param->faster_num  = ntohs(param->faster_num);
protocol.c:    if (read(session->client_fd, &param->faster_den,  2) < 0) return warn("Could not read speedup denominator");   param->faster_den  = ntohs(param->faster_den);
protocol.c:    file_size   = htonll(param->file_size);    if (write(session->client_fd, &file_size,   8) < 0) return warn("Could not submit file size");
protocol.c:    block_size  = htonl (param->block_size);   if (write(session->client_fd, &block_size,  4) < 0) return warn("Could not submit block size");
protocol.c:    block_count = htonl (param->block_count);  if (write(session->client_fd, &block_count, 4) < 0) return warn("Could not submit block count");
protocol.c:    epoch       = htonl (param->epoch);        if (write(session->client_fd, &epoch,       4) < 0) return warn("Could not submit run epoch");
transcript.c:    ttp_transfer_t  *xfer  = &session->transfer;
transcript.c:    ttp_parameter_t *param =  session->parameter;
transcript.c:    fprintf(session->transfer.transcript, "%s", logline);
transcript.c:    fprintf(session->transfer.transcript, "START %lu.%06lu\n", epoch->tv_sec, epoch->tv_usec);
transcript.c:    fprintf(session->transfer.transcript, "STOP %lu.%06lu\n\n", epoch->tv_sec, epoch->tv_usec);
transcript.c:    ttp_transfer_t  *xfer  = &session->transfer;
transcript.c:    ttp_parameter_t *param =  session->parameter;
